<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SkyLi&#39;s Thinking IN Java</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SkyLi&#39;s Thinking IN Java">
<meta property="og:url" content="http://www.skyli-blog.cn/index.html">
<meta property="og:site_name" content="SkyLi&#39;s Thinking IN Java">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SkyLi&#39;s Thinking IN Java">
  
    <link rel="alternative" href="/atom.xml" title="SkyLi&#39;s Thinking IN Java" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/head.jpg">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
        <a href="/" class="profilepic">
            
            <img lazy-src="img/head.jpg" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">SkyLi</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="https://skyli-hz.github.io/">博客首页</a></li>
                        
                            <li><a  href="/archives">文章归档</a></li>
                        
                            <li><a  href="/resume">个人简历</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl facebook"  target="_blank" href="https://www.facebook.com/sky.li.7712" title="facebook">facebook</a>
                            
                                <a class="fl mail"  target="_blank" href="/" title="mail">mail</a>
                            
                                <a class="fl github"  target="_blank" href="/" title="github">github</a>
                            
                                <a class="fl zhihu"  target="_blank" href="/" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo"  target="_blank" href="/" title="weibo">weibo</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/弹性计算/" style="font-size: 10px;">弹性计算</a> <a href="/tags/数据结构与算法/" style="font-size: 10px;">数据结构与算法</a> <a href="/tags/日常/" style="font-size: 20px;">日常</a> <a href="/tags/源码/" style="font-size: 10px;">源码</a> <a href="/tags/高可用/" style="font-size: 10px;">高可用</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://vpinfra.github.io/">INFRA</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://www.wangfeng.pro/">WANGFENG</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">向往天空-展翅翱翔</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Me">SkyLi</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Me">SkyLi</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="https://skyli-hz.github.io/">博客首页</a></li>
                
                    <li><a href="/archives">文章归档</a></li>
                
                    <li><a href="/resume">个人简历</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="facebook" target="_blank" href="https://www.facebook.com/sky.li.7712" title="facebook">facebook</a>
                    
                        <a class="mail" target="_blank" href="/" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="/" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="/" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="/" title="weibo">weibo</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/29/HashMap/" class="article-date">
      <time datetime="2019-07-29T22:12:45.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/HashMap/">HashMap 浅析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="HashMap解析"><a href="#HashMap解析" class="headerlink" title="HashMap解析"></a>HashMap解析</h1><ol>
<li><p><strong>HashMap概述</strong>：</p>
<p>HashMap实现了映射关系接口Map,是一种可处理键值对的数据结构。</p>
</li>
</ol>
<ol start="2">
<li><p><strong>HashMap数据结构</strong>：</p>
<ul>
<li><p>数组：<figure class="highlight plain"><figcaption><span>table ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    * 链表： </span><br><span class="line">``` java</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>红黑树（JDK8）：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       TreeNode&lt;K,V&gt; left;</span><br><span class="line">       TreeNode&lt;K,V&gt; right;</span><br><span class="line">       TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">       <span class="keyword">boolean</span> red;</span><br><span class="line">       ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p><strong>HashMap功能实现</strong>：</p>
<p><strong>基本概念</strong>：</p>
<p> 1、length:table的长度</p>
<p> 2、loadFactor: map 负载因子 </p>
<p> 3、threshold: threshold = length * loadFactor： 当HashMap中的key的数量达到该值时会自动扩容。</p>
</li>
</ol>
<p><strong>有参构造方法:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  loadFactor);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor; <span class="comment">// 初始化负载因子</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity); <span class="comment">// threshold 存放初始hash桶数组大小，后边在首次put对象过程中初始化hashTable时会用到</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>tableSizeFor 解析（NB）：</strong></p>
<p>在构造hashMap时，构造方法会根据实参（cap）来计算hash桶数组长度。计算方法为：tableSizeFor<br>该函数作用：根据传进来的参数得到大于且最接近该参数并且是2的幂次方的数字作为hash桶数组的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数第一行 <figure class="highlight plain"><figcaption><span>n </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弄清原因之前我们需要先来看下该函数主要做了什么操作：该函数主要对cap 进行了一系列的移位或操作，这些操作的目的是什么？我们取一个数字并将以为过程展示出来:</span><br><span class="line">这里我们假设</span><br><span class="line">```math</span><br><span class="line">n = 2^&#123;31&#125;</span><br></pre></td></tr></table></figure></p>
<p>则每次的移位或操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">       n=  ***     ;  <span class="number">1000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span></span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>;  <span class="number">1100</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将最高位拷贝到下<span class="number">1</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">2</span>;  <span class="number">1111</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将上述<span class="number">2</span>位拷贝到紧接着的<span class="number">2</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">4</span>;  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将上述<span class="number">4</span>位拷贝到紧接着的<span class="number">4</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">8</span>;  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">0000</span> <span class="number">0000</span>  <span class="number">0000</span> <span class="number">0000</span>  将上述<span class="number">8</span>位拷贝到紧接着的<span class="number">8</span>位</span><br><span class="line">n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  <span class="number">1111</span> <span class="number">1111</span>  将上述<span class="number">16</span>位拷贝到紧接着的<span class="number">16</span>位</span><br></pre></td></tr></table></figure></p>
<p>上述操作的最终目的是要把 n 的最高位右边的所有位置 1 。一遍可以找出大于该数并且是2的幂次方。那为什么要在移位或操作前先进行 cap -1 操作呢？因为如果 cap 已经是2的幂次方了（说明cap 已经满足要求，那该函数最终应该返回cap），如果不进行 cap -1 操作的话，该函数最终将返回 cap * 2，这显然不符合要求。</p>
<p><strong>定位Node所在哈希桶索引:</strong></p>
<p>hash(key) -&gt; 高位运算 -&gt; 取模运算</p>
<p>1、key hashcode + 高位运<em>**</em>算：<br>hashMap 中针对key 有专门的hash函数，该函数在Object hash值的基础上取其高16位进行了异或操作。这样做的目的是在hash桶length长度比较小的时候，让Object hash 的高位也能参与到取模操作中，能在一定成都减少hash冲突。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>2、取模运算:hash &amp; (table.length - 1)<br>在计算Node在hash桶数组的位置时，通常需要将hash值与桶数组长度取模操作：<figure class="highlight plain"><figcaption><span>% table.length```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">上文中在构造hashMap时 ```tableSizeFor```函数的返回值即hash桶数组的长度。该返回值是一个2的幂次方的数字。而 ```hash &amp; (table.length - 1)``` 与 ```hash % table.length``` 在```table.length```是2的幂次方时的作用是一样的，且 &amp; 操作 比 % 操作 占用的cpu周期更少所以其效率更高。</span><br><span class="line">``` java</span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>向HashMap中加入键值对：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果该Map第一次put对象，则初始化hash桶数组。</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 如果指定索引位置没有元素，则创建节点并放入改索引对应的数组中</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指定索引位置有元素</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 如果存在的节点与将要插入的节点相同，则直接替换</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">//如果不相同，则判断存在节点是否是树化节点，是，则将插入节点插入红黑树</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 不是树化节点，则遍历该索引桶中的链表，将节点插入链表末尾</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//插入过程中判断链表是否需要转成红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// 初始化value或者替换老的value</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从<figure class="highlight plain"><figcaption><span>源码中我们可以看到，HashMap在首次put时才初始化hash桶数组，这种设计理念很好的避免了初始加载的内存浪费问题（要避免占着坑位不拉**的场景）。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**HashMap 扩容：**</span><br><span class="line"></span><br><span class="line">1、JDK 1.7:</span><br><span class="line">``` java</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">void resize(int newCapacity) &#123; //传入新的容量</span><br><span class="line">     Entry[] oldTable = table;    //引用扩容前的Entry数组</span><br><span class="line">     int oldCapacity = oldTable.length;         </span><br><span class="line">     if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</span><br><span class="line">          threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</span><br><span class="line">     transfer(newTable);                         //！！将数据转移到新的Entry数组里</span><br><span class="line">     table = newTable;                           //HashMap的table属性引用新的Entry数组</span><br><span class="line">     threshold = (int)(newCapacity * loadFactor);//修改阈值</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JDK7 当HashMap 扩容时直接创建一个新的hash桶数组其大小为原数组长度2倍，并将原数组Node重新hash迁移到新数组中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">      Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">          Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">              src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">              <span class="keyword">do</span> &#123;</span><br><span class="line">                  Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！！重新计算每个元素在数组中的位置（重新取模操作计算新数组下标）</span></span><br><span class="line">                 e.next = newTable[i]; <span class="comment">//记录原索引指向的节点</span></span><br><span class="line">                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 这里迁移后的数据中，同一个索引的链表会出现倒置问题，详情看下图</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面以图例简单描述下迁移过程：</p>
<p>扩容前：</p>
<p><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190804221245.png" alt="扩容前"></p>
<p>扩容后：</p>
<p><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190804221030.png" alt="扩容后"></p>
<p>这里注意下元素迁移过程中的规律，假设 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">扩容前下标：</span><br><span class="line"></span><br><span class="line">| 字段名称 |  value(二进制) |数组下标|</span><br><span class="line">| --- | --- |---|</span><br><span class="line">| length - 1 | 0000 0000 0000 0000 0000 0000 0000 0011 | |</span><br><span class="line">| hash(A) | 0010 0000 0110 0000 0000 0000 0000 0010 | 1|</span><br><span class="line">| hash(B) |0010 0000 0110 0000 0000 0000 0000 0110 | 1|</span><br><span class="line">| hash(C) |0010 0000 0110 0000 0000 0000 0000 0110 | 1 |</span><br><span class="line"></span><br><span class="line">扩容后下标：</span><br><span class="line"></span><br><span class="line">| 字段名称 |  value(二进制) |数组下标|</span><br><span class="line">| --- | --- |---|</span><br><span class="line">| length - 1 | 0000 0000 0000 0000 0000 0000 0000 0111 | |</span><br><span class="line">| hash(A) | 0010 0000 0110 0000 0000 0000 0000 0010 | 1|</span><br><span class="line">| hash(B) |0010 0000 0110 0000 0000 0000 0000 0110 | 5 (1 + 4）|</span><br><span class="line">| hash(C) |0010 0000 0110 0000 0000 0000 0000 0110 | 5  (1 + 4) |</span><br><span class="line"></span><br><span class="line">当数组扩容后，则``` length -1 ``` 二进制在高位会多一个 1， 即：上表（```length -1 ``` 最低4位）中的 ```0011 -&gt; 0111```,所以凡是``` hash(key)``` 的最高位与length的二进制非零最高位相与不为0的，则在扩容后的数组中下标为 ```oldIndex + oldCap```.</span><br><span class="line"></span><br><span class="line">JDK8的这种设计非常巧妙，不仅在针对将老Hash桶数组中的数据迁移到新数组中不用重新计算每个Node的hash值与新数组的取模操作；而且由于每个key 的hash值中对应新增的1bit是 0 还是 1 是随机的，这就保证了在扩容前由于hash冲突而组成链表节点可以均匀的分散到新的bucket中。 并且迁移后的数据不存在倒置问题。</span><br><span class="line">详情看JDK8的resize（）：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr = threshold;</span><br><span class="line">        int newCap, newThr = 0;</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;// 如果数组容量已经达到最大值，则调整阈值后直接返回不进行扩容。</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            // 否则直接将通数组length * 2</span><br><span class="line">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">            newCap = oldThr;// 这里第一次初始化通数组时容量取tableSizeFor函数的返回值。该值被复制在 threshold 变量中。</span><br><span class="line">        else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (newThr == 0) &#123;</span><br><span class="line">            float ft = (float)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];// 创建新的length的数组</span><br><span class="line">        table = newTab;</span><br><span class="line">        // 数据迁移</span><br><span class="line">        if (oldTab != null) &#123;</span><br><span class="line">            for (int j = 0; j &lt; oldCap; ++j) &#123;// 遍历原数组的所有链表</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                    oldTab[j] = null;// 释放原节点空间</span><br><span class="line">                    if (e.next == null)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] = e;// 如果链表只有一个节点，则直接将节点放入对应下标的新hash桶数组中。</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; // preserve order</span><br><span class="line">                        Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        // 遍历链表</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            if ((e.hash &amp; oldCap) == 0) &#123;// 这一步非常NB， 判断key的hash值在新增的1 bit 是否是 1， 如果是 则将其放入hiHead或者hiTail链表中。</span><br><span class="line">                                if (loTail == null)// 尾插</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if (hiTail == null) // 尾插</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e = next) != null);</span><br><span class="line">                        if (loTail != null) &#123;</span><br><span class="line">                            loTail.next = null;</span><br><span class="line">                            newTab[j] = loHead; // 将loHead指向的链表放入低bucket（见元素转移图）</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail != null) &#123;</span><br><span class="line">                            hiTail.next = null;</span><br><span class="line">                            newTab[j + oldCap] = hiHead; // 直接将hiHead 指向的链表放入高bucket中（见元素转移图）</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>JDK8中采用4个Node（hiHead、hiTail、loHead、loTail）节点(采用尾插发)来保证转移后的高低bucket中的链表顺序，不会出现JDK7中链表转移到新数组中的倒置问题。</p>
<p><strong>HashMap使用注意事项：</strong></p>
<pre><code>1、禁止使用可变对象作为key.
</code></pre><p>任何对象的hashcode方法继承于Object基类。其取对象在堆内存中的对象的起始地址，如果选择重写对象的hashcode方法，则hashcode的生成应尽量避免关联对象属性。否则，在改变对象的field属性时，对应的hashcode值也会变更，从而无法操作先前存入的value，造成内存泄漏。</p>
<pre><code>2、非线程安全，多线程并发可能会产生数据不一致问题。
</code></pre><p>可使用Hashtable 或者 ConcurrentHashMap替换。</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/Java/">Java</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码/">源码</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-how-to-use-elastic-job" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/31/how-to-use-elastic-job/" class="article-date">
      <time datetime="2019-01-31T13:12:45.000Z" itemprop="datePublished">2019-01-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/31/how-to-use-elastic-job/">Elastic-Job 使用详解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>EJ(Elastic-Job,下文所有命名使用该简写)应用场景：<br>1、分布式环境中运行应用定时任务。</p>
<p>EJ是当当网开源的一个分布式任务调度的框架，该项目是基于Quartz、Zookeeper进行的二次开发。其最大的优点在于支持服务器的动态弹性扩容，并且保证同意作业分片同一时刻只在一个服务器节点上运行。</p>
<p>废话不多说：先上一张EJ整体架构图：<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131141956.png" alt="EJ架构图"><br>具体实现原理请参考官方文档：<a href="http://elasticjob.io/docs/elastic-job-lite/00-overview/" target="_blank" rel="noopener">EJ官方文档</a></p>
<p>下面主要说下如何将EJ整合到项目中；官网提供了两种方式：SpringXML、Java配置；</p>
<p>整合前首先需要将EJ的maven依赖添加到项目pom文件中，如果不知道该选择什么版本，可到maven仓库中查看具体的可用版本：<a href="https://mvnrepository.com/" target="_blank" rel="noopener">MVN仓库</a></p>
<p>这里需要以下依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.dangdang&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elastic-job-lite-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果是spring项目的话，还需要添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.dangdang&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elastic-job-lite-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>针对传统spring项目，如果使用传统的xml配置方式，EJ提供了特定的spring命名空间，可以方便的配置EJ相关配置比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:reg=&quot;http://www.dangdang.com/schema/ddframe/reg&quot;</span><br><span class="line">    xmlns:job=&quot;http://www.dangdang.com/schema/ddframe/job&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">                        http://www.dangdang.com/schema/ddframe/reg</span><br><span class="line">                        http://www.dangdang.com/schema/ddframe/reg/reg.xsd</span><br><span class="line">                        http://www.dangdang.com/schema/ddframe/job</span><br><span class="line">                        http://www.dangdang.com/schema/ddframe/job/job.xsd</span><br><span class="line">                        &quot;&gt;</span><br><span class="line">    &lt;!--配置作业注册中心 --&gt;</span><br><span class="line">    &lt;reg:zookeeper id=&quot;regCenter&quot; server-lists=&quot;yourhost:2181&quot; namespace=&quot;dd-job&quot; base-sleep-time-milliseconds=&quot;1000&quot; max-sleep-time-milliseconds=&quot;3000&quot; max-retries=&quot;3&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 配置作业--&gt;</span><br><span class="line">    &lt;job:simple id=&quot;demoSimpleSpringJob&quot; class=&quot;xxx.MyElasticJob&quot; registry-center-ref=&quot;regCenter&quot; cron=&quot;0/10 * * * * ?&quot; sharding-total-count=&quot;3&quot; sharding-item-parameters=&quot;0=A,1=B,2=C&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>配置成功后，项目在启动时会自动创建对应的Bean到spring容器中。</p>
<p>如果使用Java显示指定配置时，首先需要在properties或yml文件中指定zk的服务器地址与节点命名空间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zk.elastic.job.server-lists=ip:端口</span><br><span class="line">zk.elastic.job.namespace=skyli</span><br></pre></td></tr></table></figure></p>
<p>然后显示配置zk注册中心的bean:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConfigurationProperties(prefix = &quot;zk.elastic.job&quot;)</span><br><span class="line">public class ZkRegConfig &#123;</span><br><span class="line">    private String serverlists;</span><br><span class="line">    private String namespace;</span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public ZookeeperConfiguration zookeeperConfiguration() &#123;</span><br><span class="line">        return new ZookeeperConfiguration(serverlists, namespace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(initMethod = &quot;init&quot;)</span><br><span class="line">    public ZookeeperRegistryCenter zookeeperRegistryCenter(ZookeeperConfiguration zookeeperConfiguration) &#123;</span><br><span class="line">        return new ZookeeperRegistryCenter(zookeeperConfiguration);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中@Bean(initMethod = “init”)注解将在bean初始化时调用init方法去连接zk；</p>
<p>接下来需要针对分布式作业进行配置，EJ有三种类型的Job：</p>
<ol>
<li>SimpleJob</li>
<li>DataflowJob</li>
<li>ScriptJob</li>
</ol>
<p>每种类型的Job有什么功能与区别请参考官方文档。</p>
<p>这里主要讲一下SimpleJob的配置方法，其他类型的配置也是大同小异：<br>EJ针对作业有三种配置：</p>
<ol>
<li>JobCoreConfiguration</li>
<li>JobTypeConfiguration</li>
<li>JobRootConfiguration</li>
</ol>
<p>每种配置相互依赖，最终确定一个作业的配置，举个获取作业配的栗子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private LiteJobConfiguration getLiteJobConfiguration(final Class&lt;? extends SimpleJob&gt; jobClass, final String cron, final int shardingTotalCount, String shardingParamters) &#123;</span><br><span class="line">       return LiteJobConfiguration.newBuilder(</span><br><span class="line">               new SimpleJobConfiguration(JobCoreConfiguration.newBuilder(jobClass.getName()</span><br><span class="line">               , cron, shardingTotalCount).shardingItemParameters(shardingParamters).build()</span><br><span class="line">               , jobClass.getCanonicalName()))</span><br><span class="line">               .overwrite(true).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中该方法的第一个形参为要执行任务的class对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyThreeTask implements SimpleJob &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(ShardingContext sc) &#123;</span><br><span class="line">        System.out.println(String.format(&quot;任务名称:%s\n 分片项%s\n 分片总数%s\n 分片参数%s\n&quot;</span><br><span class="line">                , sc.getJobName()</span><br><span class="line">                , sc.getShardingItem()</span><br><span class="line">                , sc.getShardingTotalCount()</span><br><span class="line">                , sc.getShardingParameter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后边的参数为特定Job的配置：包括cron表达式、分片参数、分片总数等配置，将每种配置定义在properties或yml中（栗子）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elastic.job.serverlists=localhost:2181</span><br><span class="line">elastic.job.namespace=skyli</span><br><span class="line">elastic.job.scheduleCron=0/5 * * * * ?</span><br><span class="line">elastic.job.shardingTotalCount=3</span><br><span class="line">elastic.job.sharding-parameters=0=A,1=B</span><br></pre></td></tr></table></figure></p>
<p>针对特定作业的配置请参考官方文档中的配置详解，其详细说明了每种配置的功能。</p>
<p>紧接着初始化JobScheduler:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private SimpleJob myThreeTask;</span><br><span class="line"></span><br><span class="line">@Bean(initMethod = &quot;init&quot;)</span><br><span class="line">public JobScheduler myThreeJobScheduler() &#123;</span><br><span class="line">        return new SpringJobScheduler(myThreeTask, zookeeperRegistryCenter, getLiteJobConfiguration(myThreeTask.getClass(), scheduleCron, shardingTotalCount, null));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一个可以在分布式环境中运行的Job便定义好了，spring项目在多个服务器中运行时，该Job便能根据分片策略将不同的分片分派到指定服务器运行了,看下运行结果（两台服务器）：<br>服务器1:<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131125146.png" alt=""><br>服务器2：<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131130623.png" alt=""></p>
<p>不知大家有没有发现有什么不妥的地方？ 定义一个简单的分布式作业需要配置大量的代码，无论你采用什么方式（xml或者java显示配置）。</p>
<p>那么在SpringBoot盛行的今天，快速敏捷开发成了主流趋势，我们需要尽量少的配置便可以将EJ整合到项目中，而EJ官方并没有针对SpringBoot项目提供官方的starter依赖。基于此需求也方便司内同事可以快速使用EJ，本人封装了一套EJ的starter依赖，目前只是针对SimpleJob类型的作业提供支持。该starter目前处于公司司内部项目使用阶段，后期会公布在本人的GitHub上。</p>
<p>下面简单介绍改starter依赖的使用方法：<br>首先需要在pom文件中引用该starter（目前该项目只发布在公司内部Maven仓库中，外部不可用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.vpgame.infra&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dd-elastic-job-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后需要在spring application.properties或者yml文件中添加zk配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zk.elastic.job.server-lists=ip:port</span><br><span class="line">zk.elastic.job.namespace=your namespace</span><br></pre></td></tr></table></figure></p>
<p>紧接着只需要在定义Job是在类声明时添加@JobConf注解便能完成分布式Job的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@JobConf(name = &quot;mySimpleTask&quot;</span><br><span class="line">        , cron = &quot;0/5 * * * * ?&quot;</span><br><span class="line">        , shardingTotalCount = 3</span><br><span class="line">        , shardingParameters = &quot;0=A,1=B&quot;)</span><br><span class="line">public class MyThreeTask implements SimpleJob &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute(ShardingContext sc) &#123;</span><br><span class="line">        System.out.println(String.format(&quot;任务名称:%s\n 分片项%s\n 分片总数%s\n 分片参数%s\n&quot;</span><br><span class="line">                , sc.getJobName()</span><br><span class="line">                , sc.getShardingItem()</span><br><span class="line">                , sc.getShardingTotalCount()</span><br><span class="line">                , sc.getShardingParameter()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别将项目在不同服务器上启动，便可以看到定义的作业在不同机器上运行的情况（运行结果与上述单独配置运行结果相同）：<br>服务器1:<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131125146.png" alt=""><br>服务器2：<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131130623.png" alt=""></p>
<p>OK，如何将EJ整合到项目中就说到这里吧！^_^</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/中间件-Elastic-job/">中间件:Elastic-job</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/弹性计算/">弹性计算</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-dsaa_01" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/06/dsaa_01/" class="article-date">
      <time datetime="2019-01-06T22:12:45.000Z" itemprop="datePublished">2019-01-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/06/dsaa_01/">算法复杂度分析(上)：时间复杂度</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>正式进入专题之前，首先给一张关于数据结构与算法的图谱：图片来源与极客时间王争大神的数据结构与算法专栏课中。</p>
<p><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131150357.png" alt="数据结构与算法"><br>下面我们进入正题：<br>数据结构与算法的目的就是让我们的程序执行时间更快，存储空间更省。那我们如何来评价一个算法的好坏，评价的依据又是什么呢？</p>
<ol>
<li>为什么需要复杂度分析？</li>
</ol>
<p>你可能会疑惑？复杂度分析的意义是什么？一段代码执行时间的快慢随时可以在机子上测试出来，而且测试出来的准确度肯定是比我们通过推理分析得出的复杂度分析更加准确！</p>
<p>没错，一段代码的执行效率我们确实可以实际的测出来，但是通过这种手段测出的代码执行效率是不具有普遍代表性的，因为一段代码执行效率的好坏是与执行代码的环境紧密相关的，一段相同的代码分别在几年前的老电脑和现在的电脑上运行，执行的时间肯定是不同的！而且这种“事后统计”的方法针对我们写出好的程序的预判性是没有太大的帮助的。</p>
<p>所以，算法的复杂度分析还是存在很大价值的！它可以大致的评估出我们程序的性能！算法的执行效率通俗的说就是就是算法的执行时间。比如下面的一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在计算机CPU中执行无外乎就是每行代码的读取、计算，写数据等操作，尽管每行代码在CPU中执行的时间不一样，但是我么这里只做粗略的计算，假设每行代码在CPU中的执行时间是相同的，这里记为：unit_time，则上述所有代码行的执行时间就是2<em>unit_time + 2n</em>unit_time。我们将执行总时间记为：T(n) = 2<em>unit_time + 2n</em> unit_time。可以看出代码执行的总是间与n成正比。</p>
<p>所以执行总时间总结为一个公式就为：T(n)=O(f(n)), 其中T（n）就是代码运行的总时间，O表示执行时间与n成正比。这就是大O时间复杂度表示法。</p>
<p>通常，大O表示的不是某段代码的具体执行时间，而是表示代码执行时间与随代码规模n增长的变化趋势，所以，在时间复杂度表示中，常量、系数等对增长趋势影响并不大，故上述代码的时间复杂度可以表示为O（n）。</p>
<p>2.常见的时间复杂度类别分析实例：</p>
<p><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131150143.png" alt="时间复杂度类别"></p>
<ul>
<li><p>常量阶O(1)<br>常量阶O(1)并不表示代码只执行了一行，通常代码中只要没有循环，递归；则再多的代码时间复杂度也为O(1).<br>栗如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 8;</span><br><span class="line">int j = 6;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对数阶O(logn)<br>栗如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1;</span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line">  i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上述代码的时间复杂度为：O(logn)。不论以几为底的对数都表示为O(logn)，因为都可以互相转化为对应常数系数：C<em>logn，而O(logn)=O(C</em>lobn)。</p>
<p>还有其他一些类别的复杂度，这里就不举例子了，上述的复杂度类别涵盖了现实中90%的算法复杂度！</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-what-is-the-encoding" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/01/01/what-is-the-encoding/" class="article-date">
      <time datetime="2019-01-01T00:00:00.000Z" itemprop="datePublished">2019-01-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/01/what-is-the-encoding/">彻底搞懂计算机编码</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>世界上有形形色色的语言，不同的民族通过各自的语言交流！</p>
<p>针对计算机而言，属于计算机的语言便是有0和1组成的二进制数据。任何类型的数据如果需要被计算机处理与识别，则必须将其转为数字才能处理。</p>
<p>早期计算机在设计时采用的是8个比特（bit）作为一个字节（byte），所以转化为十进制一个字节最大可以表示为255（11111111）。</p>
<p>如果要表示更大的整数，则需要更多的字节，两个字节最大可以表示为65535，4个字节最大可以表示为4294967295。</p>
<p>由于计算机是美国佬发明的，所以最早的时候美国人将一些基本的字符编码到计算机里，这些基本字符包括大小写英文字母、数字和一些特殊符号总共127个字符。由这些编码组成的表就是注明的ASCLL表。比如大写字母A的编码为65，小写字母a的编码为97等。</p>
<p>后来，随着世界互联网的发展，不同国家需要在计算机上表达各自的本国语言，比如说中国需要在计算机中处理汉子等文本数据，一个汉子用一个字节是肯定表示不过来的，因为中国汉子有几千个。针对汉子的编码至少需要两个字节，所以为了针对汉子的编码不与ASCLL冲突，中国制定了GB2312,用来把汉子编码进去。</p>
<p>可想而知，每个国家都有自己的语言，如果每个国家都各自指定了自己的编码标准，则计算机在不同国家之间通信时，不可避免的会出现乱码现象。</p>
<p>至此，Unicode编码应运而生，Unicode把所有语言都统一到一套编码里，这样就不会出现乱码了。</p>
<p>Unicode编码标准也在一直发展，常见的是用两个字节表示一个字符（比较偏僻的字符会使用4个字节表示）。</p>
<p>现在捋一捋ASCLL与Unicode的区别：ASCLL使用一个字节编码，Unicode使用两个字节编码。<br>字母A用ASCLL编码十进制是65，二进制为：<strong><span style="color:#ec6d02">01000001</span></strong><br>汉子“中”已经无法使用ASCLL表示，使用Unicode表示为十进制是20013，二进制为：<strong><span style="color:#ec6d02">01001110 00101101</span></strong></p>
<p>所以如果字符A使用Unicode编码的话，只需要将第一个字节全部用0填充就行了，表示为：<strong><span style="color:#ec6d02">00000000 01000001</span></strong></p>
<p>这样就万事大吉了吗？你有想到新的问题吗？那就是如果我的一篇文章全部用英文书写，如果使用Unicode编码的话，在计算机中占用的存储空间会比使用ASCLL编码多一倍！这显然是不合理的，虽然说当代计算机的存储能力很强！</p>
<p>所以本着节约的精神，一种可变长的编码方式应运而生，它就是我们最常见的UTF-8。怎么样，是不是超级熟悉。</p>
<p>UTF-8根据Unicode表示字符的数字大小，将字符使用1~6个字节动态编码，常用的英文字母使用一个字节，汉子使用3个字节，只有生僻的字符才用更多的字节表示。所以如果传输的文本中含有大量的英文的话，使用UTF-8比Unicode会节省大量空间。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>ASCLL</th>
<th>Unicode</th>
<th>UTF-8</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>01000001</td>
<td>00000000 01000001</td>
<td>01000001</td>
</tr>
<tr>
<td>中</td>
<td>x</td>
<td>01001110 00101101</td>
<td>11100100 10111000 10101101</td>
</tr>
</tbody>
</table>
<p>根据上述表格可以发现，UTF-8在表示字符A时与ASCLL的编码值相同，所以使用UTF-8的一个额外好处是，UTF-8兼容使用ASCLL编码的数据，所以一些使用ASCLL编码的历史遗留软件在UTF-8环境中依然可以使用。</p>
<p>明白了ASCLL、Unicode、UTF-8之间的关系，我们来总结一下，现代计算机操作系统通用的字符编码工作方式：<br>在计算机内存中使用的是Unicode编码，当需要保存到硬盘或者传输的时候将数据编码转为UTF-8。<br>使用一些文本变价软件编辑文本时，从文件读取的UTF-8字符被转Unicode字符传输到内存中。编辑完成时再由Unicode转为UTF-8。当然现在编辑软件也可以设置对应的编码方式。</p>
<p>好了，本文就说到这里吧，是不是对计算机编码有了新的认识。哈哈，本文参考廖大神的网站Python教程，原文请参考：<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431664106267f12e9bef7ee14cf6a8776a479bdec9b9000" target="_blank" rel="noopener">这里</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/计算机基础/">计算机基础</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日常/">日常</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hystrix-principle" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/15/hystrix-principle/" class="article-date">
      <time datetime="2018-08-15T22:12:45.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/15/hystrix-principle/">菜鸟浅谈Hystrix</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="Hystrix是什么？"><a href="#Hystrix是什么？" class="headerlink" title="Hystrix是什么？"></a>Hystrix是什么？</h2><p> Hystrix 是<a href="https://www.netflix.com/" target="_blank" rel="noopener">Netflix</a>为了预防服务间因某个服务故障导致整个系统雪崩而设计的高可用服务容错框架！有点抽象？往下看。。。</p>
<h2 id="Hystrix要解决的问题？"><a href="#Hystrix要解决的问题？" class="headerlink" title="Hystrix要解决的问题？"></a>Hystrix要解决的问题？</h2><p> <strong>应用背景:</strong><br> 在复杂的分布式系统架构中，服务间复杂的依赖关系，而每个服务的可用性不能得到充足的保证，如果服务没有和自己的依赖服务进行隔离，那么可能某一个依赖服务的故障就会拖垮当前这个服务。<br> Hystrix就是通过响应策略阻止当前服务被拖垮的一个容错框架！</p>
<p><strong>有点抽象？看下图。。。</strong><br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131145652.png" alt="服务依赖"><br>任何应用（或者说任何服务）通常是部署在一个web容器中供外部用户调用，常见的web容器：大家最熟悉的Tomcat或者Weblogic、Jboss、Jetty等。<br>外部用户的每次调用，web容器都将启动一个线程去处理请求。<br>举个栗子：<br>月底到了，小明（用户请求）的工作任务没有完成，小明需要在两天时间内完成A、H、I、P四个任务（服务）！！！<br>正常情况下，如果时间安排妥当且中间不出现问题的话，那小明能够很轻松的完成目标任务。万事大吉。。。阿弥陀佛。。。</p>
<p>但是事情总没有想象的那么完美，完成任务I中间出现了一些问题。导致小明没有完成，但是小明不知道是什么原因，他没有放弃，一直尝试着完成任务I。。。。<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131145732.png" alt="服务依赖"><br>就这样，小明将剩余的两天时间全部用在了解决任务I（web容器启动其他线程去调用服务），但一直没有完成，两天的时间用完了（web容器的线程资源用完了）。。。。<br>最终小明被领导痛批了一顿，差点丢了工作（整个系统差点雪崩）！<br><img src="https://raw.githubusercontent.com/lz330718637/Images/master/20190131145810.png" alt="服务依赖"><br>发现这个例子不咋地（尴尬。。。）还是用比较正式的话描述一下吧：<br>上面三张图表示通常在服务调用中从最开始的正常调用，到出现一个调用异常（调用方没有获取依赖服务I的响应，当前线程卡住，则线程资源得不到释放，如果这对该服务的并发访问比较高的话，其他线程资源都会来调用该服务）最后所有的进程资源全部用来访问该服务而导致资源耗尽从而使当前服务崩溃，最后可能整个分布式系统的雪崩！</p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/微服务/">微服务</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高可用/">高可用</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/13/hello-world/" class="article-date">
      <time datetime="2018-08-13T22:12:45.000Z" itemprop="datePublished">2018-08-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技巧/">技巧</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/日常/">日常</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2019 SkyLi
            </div>
            <div class="footer-right">
                More Themes in <a href="http://hexo.io/" target="_blank">Hexo</a> ^_^ And welcome to <a href="https://www.skyli-blog.cn/" target="_blank">skyli-blog</a>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >博客到访量: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>


    <script type="text/javascript">
      window.onload = function(){
        document.getElementById("search").onclick = function(){
            console.log("search")
            search();
        }
      }
      function search(){
        (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
        (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
        e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
        })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

        _st('install','A1Pz-LKMXbrzcFg2FWi6','2.0.0');
      }
    </script>

  </div>
</body>
</html>